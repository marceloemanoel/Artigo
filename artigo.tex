\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{graphicx,url}
\usepackage{framed}
\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage{fontenc}

% Definição do template de formatação e synthax hightlight para groovy :)
%
\lstdefinelanguage{Groovy}{keywords={
                                            abstract, default, if, private, this,
                                            boolean, do, implements, protected, 
                                            throw, break, double, import, public, 
                                            throws, byte, else, instanceof, return,
                                            transient, case, extends, int, short, 
                                            try, catch, final, interface, static, 
                                            void, char, finally, long, strictfp,
                                            volatile, class, float, native, super, 
                                            while, const, for, new, switch, continue,
                                            goto, package, synchronized, def, any, 
                                            as, in, with, null, true, false, static
                                },
                                keywords={[2]params, render,it, flash, redirect},
                                morecomment=[l]{//},
                                morecomment=[s]{/*}{*/},
                                morestring=[b]",
                                morestring=[d]',
                                morestring=[b]""",
                                morestring=[b]''',
                                morestring=[b]/
                           }

%
%   Definição de estilos das linguagens
%
%\lstdefinestyle{Listagem}{
%                        \lstlistingname
%                        }
\lstdefinestyle{Groovy}{
                            upquote=true,
                            basicstyle=\small,
                            keywordstyle=\color[RGB]{151,40,120},
                            keywordstyle={[2]\color[RGB]{102, 204, 255}},
                            stringstyle={\color[RGB]{255,0,204}
                                         \ttfamily
                                         \small
                            },
                            identifierstyle=\ttfamily,
                            breaklines=true,
                            showtabs=false,
                            showspaces=false,
                            showstringspaces=false,
                            columns=fullflexible,
                            numbers=left,
                            language=Groovy,
                            name=Listagem
                            extendedchars=true,
                            frame=leftline
                       }
\lstdefinestyle{InlineGroovy}{
                           style=Groovy,
                           numbers=none
                      }
\lstdefinestyle{Java}{
                        keywordstyle={\color[RGB]{127,0,85} \ttfamily \small },
                        stringstyle={\color[RGB]{42,0,255} \ttfamily \small},
                        commentstyle={\color[RGB]{63,127,95} \ttfamily \small},
                        upquote=true,
                        basicstyle=\small,
                        breaklines=true,
                        showtabs=false,
                        showspaces=false,
                        showstringspaces=false,
                        columns=fullflexible,
                        numbers=left,
                        language=Java,
                        name=Listagem,
                        frame=leftline                   
                     }

\sloppy

\title{Groovy on Rails, uma alternativa para o desenvolvimento de aplicações web
       sem sair da Plataforma Java}

\author{Marcelo Emanoel Bezerra Diniz\inst{1}}

\address{
    Centro de Ciências Tecnológicas -- Universidade de Fortaleza (UNIFOR)\\
    CEP 60.811-905 -- Fortaleza -- CE -- Brasil
}

\begin{document} 

\maketitle

\begin{resumo} 
    
    Desde seu surgimento a plataforma Java se destaca como uma ótima alternativa
    para o desenvolvimento de aplicações web. Diversos frameworks surgiram para 
    proporcionar reutilização de código e aumento de produtividade. A plataforma
    possui implementações robustas e amplamente utilizadas. Porém, apesar dos 
    esforços, outras tecnologias mais recentes vem se destacando e tomando a 
    frente no cenário de desenvolvimento de aplicações para a web. Dentre estas 
    tecnologias são notórias algumas características como o uso de linguagens 
    dinâmicas em conjunto com padrões de projeto amplamente conhecidos. Neste 
    artigo será abordado o framework Groovy on Rails, ou simplesmente, Grails. 
    O framework alia a linguagem dinâmica groovy
    à arquitetura utilizada no Ruby on Rails. \nocite{*}
    
\end{resumo}

\section{Introdução}

    Alta competitividade, baixo custo de produção e manutenção, além de alta 
    qualidade são exigências do mercado de desenvolvimento de software. 
    Independentemente da tecnologia envolvida no processo de construção de uma 
    aplicação web, existe o componente de complexidade inerente ao próprio 
    ambiente. Toda a comunicação é baseada no protocolo HTTP. Sua simplicidade 
    garante a alta disponibilidade da Web, porém requer um trabalho adicional 
    das aplicações para manter as informações seguras e íntegras.

    No cenário previamente descrito, a Plataforma Java se destacou desde o seu 
    surgimento. A fim de facilitar o desenvolvimento das aplicações para este 
    ambiente, surgiram diversos frameworks, bases de infra-estruturas 
    extensíveis, voltadas para um nicho em particular. A partir destas o 
    desenvolvedor irá retirar os insumos para a construção de aplicações.

    Com o passar do tempo outras linguagens dentro e fora da plataforma foram 
    surgindo com propostas um pouco diferentes da linguagem Java. Algumas com 
    características funcionais, outras com características totalmente orientadas 
    a objetos. Porém todas com um foco em comum, aumento de produtividade, 
    possibilitando entregar mais funcionalidades com menos código. Em cima 
    dessas novas linguagens, novos frameworks foram sendo desenvolvidos para 
    resolver de forma melhor os antigos problemas.
    
    Nesse cenário, por volta do ano de 2006, surgiu o framework Ruby on Rails 
    para a linguagem Ruby. Suas bases advêm do padrão de projeto MVC. Voltado 
    para o desenvolvimento de aplicações web, rapidamente adquiriu adeptos por 
    facilitar e agilizar a criação de aplicações através de geradores de código 
    para as tarefas comuns além é claro da utilização de uma linguagem de mais 
    fácil compreensão.

    Com a popularização desse conjunto de novas linguagens, implementações 
    baseadas na Java Virtual Machine, JVM, foram surgindo. Através da JSR, Java 
    Specification Request, número 223, a integração de linguagens de script foi 
    facilitada. Nesse contexto uma nova linguagem surgiu, Groovy. Sua plataforma 
    única é a JVM, isso significa que o compilador da linguagem produz o mesmo
    bytecode gerado pelo compilador Java. E que portanto, automaticamente um 
    extenso conjunto de bibliotecas pré-existentes e maduras pode ser utilizado 
    na nova linguagem de maneira transparente para o desenvolvedor. 
    
    Com a popularização do Ruby on Rails muitas de suas funcionalidades foram 
    incorporadas por alguns frameworks mesmo que em outras linguagens. A 
    abordagem utilizada no Groovy on Rails, Grails, possui algumas similaridades 
    e algumas diferenças. Seu foco está em utilizar fórmulas consagradas na 
    Plataforma Java e aliar às inovações do Rails produzindo um ambiente de alta 
    produtividade utilizando soluções maduras.
    
    Nas seções seguintes serão descritos os principais conceitos da linguagem 
    Groovy e do framework Grails.

\section{A linguagem Groovy} \label{sec:linguagem_groovy}

    A linguagem Groovy é relativamente nova, foi criada em  Agosto de 2003, é 
    dinamicamente tipada e pode ser interpretada ou compilada. Foi elaborada 
    para ser executada especificamente pela Java Virtual Machine (JVM) e sofreu 
    grande influência das linguagens Ruby, Python, Perl, Smalltalk e obviamente 
    de Java.
    
    Como dito anteriormente, a linguagem Groovy foi elaborada tendo a JVM como 
    plataforma principal. Isso permitiu que pouca ou nenhuma distorção possa 
    existir entre as linguagens, além disso, esta escolha reduziu de maneira 
    drástica a curva de aprendizado. Sua API, Application Programming Interface, 
    é toda baseada na API Java padrão, aliado a isto, a integração com a JVM no 
    nível de bytecode permite a interoperabilidade de Java para Groovy bem como 
    o caminho reverso. Dessa maneira, desenvolvedores Java automaticamente 
    também desenvolvem em Groovy.
    
    Dentre as funcionalidades que a linguagem possui é possível citar o uso de 
    closures,  e propriedades nativas bem como a utilização de meta-programação, 
    que como conseqüência direta proporciona a criação das chamadas Domain 
    Specific Languages ou simplesmente DSL's.

\subsection{Instalação}
    
    No endereço \url{http://groovy.codehaus.org/Download} é possível fazer o 
    download das ferramentas necessárias à utilização da linguagem. Lá é possível
    encontrar instaladores para as plataformas Windows e Debian bem como a versão
    binária que pode ser usada em qualquer sistema operacional. Para o Mac Os X 
    é possível utilizar algum dos gerenciadores de pacotes existentes como o 
    macports ou o homebrew.
    
    Neste artigo será exemplificada a instalação a partir da versão binária pela 
    independência de plataforma. O primeiro passo é descompactar o arquivo em 
    algum diretório e criar a variável de ambiente \emph{GROOVY\_HOME} que aponta 
    para o diretório em questão. O passo seguinte é adicionar ao \emph{PATH} do 
    ambiente a variável recém criada. Caso ainda não exista, é necessário criar 
    a variável de ambiente \emph{JAVA\_HOME} que aponta para o diretório da 
    instalação do Java Development Kit.
    
    Após os passos do parágrafo anterior deve ser possível agora executar no 
    console os comandos:
    
    \begin{description}
        \item [groovysh:] Abre o Groovy Shell
        \item [groovyConsole:] Abre o console gráfico do Groovy 
        \item [groovy:] Executa um arquivo groovy
        \item [groovyc:] Compila um arquivo .groovy em .class
    \end{description}
    
\subsection{Groovy Script}
    
    Como dito anteriormente, Groovy pode ser utilizado como uma linguagem de 
    script para execução de tarefas rápidas. Para exemplificar, veremos o clássico
    exemplo HelloWorld utilizando Groovy como script. A listagem \ref{HelloGroovyScript}
    mostra o conteúdo do arquivo Hello.groovy. 
    
    \lstinputlisting[   
                        style=Groovy,
                        caption=Hello World Groovy Script,
                        label=HelloGroovyScript
                    ]
                    {src/groovy/Hello.groovy}

    Executando o comando:
    \begin{lstlisting}[language=]
        groovy Hello.groovy
    \end{lstlisting}
    
    O resultado, como esperado, é que no console o texto "Hello Groovy Script World"
    seja impresso. Isso acontece por que o interpretador internamente cria um 
    método main e insere o código contido no arquivo Hello.groovy. O código Java
    equivalente pode ser observado na listagem \ref{HelloGroovyScriptInJava}.
    
    \lstinputlisting[
                        style=Java,
                        caption=Hello World Groovy Script em Java,
                        label=HelloGroovyScriptInJava
                    ]
                    {src/java/Hello.java}

\subsubsection{Funções de Script}

    Assim como outras linguagens de script é possível criar blocos de código 
    reutilizáveis, as funções. A listagem \ref{HelloGroovyScriptWithFunctions} 
    fornece um exemplo da sintaxe utilizada para a declaração de funções.
    
    \lstinputlisting[
                        style=Groovy,
                        caption=Hello World Groovy Script Com Funções,
                        label=HelloGroovyScriptWithFunctions,
                    ]
                    {src/groovy/HelloWithFunctions.groovy}
   

\subsection{Strings}

    Strings em Groovy podem ser definidas de até cinco formas diferentes, são elas:
    
    \begin{enumerate}
        \item entre aspas duplas: 
            \begin{lstlisting}[style=InlineGroovy]
                "Marcelo Emanoel"
            \end{lstlisting}
        \item entre aspas simples:
            \begin{lstlisting}[style=InlineGroovy]
                'Marcelo Emanoel'
            \end{lstlisting}
        \item entre barras:
            \begin{lstlisting}[style=InlineGroovy]
                /Marcelo Emanoel/
            \end{lstlisting}
        \item entre três aspas duplas: 
            \begin{lstlisting}[style=InlineGroovy]
                """Marcelo Emanoel"""
            \end{lstlisting}
        \item entre três aspas simples:
            \begin{lstlisting}[style=InlineGroovy]
                '''Marcelo Emanoel'''
            \end{lstlisting}

    \end{enumerate}
    
    A depender da forma declarada é possível que a string produzida aceite ou não
    o uso de interpolação, ou seja, a inserção de expressões que serão avaliadas
    e concatenadas à string. A listagem \ref{HelloGroovyScriptWithFunctions} exibe
    este conceito na linha 2 onde o resultado da expressão delimitada por \$\{ e \}
    é concatenado à string. A listagem \ref{HelloGroovyScriptWithFunctionsInJava}
    exibe o código Java equivalente.
    
    \lstinputlisting[
                        style=Java,
                        caption=Hello World Groovy Script Com Funções Em Java,
                        label=HelloGroovyScriptWithFunctionsInJava
                    ]
                    {src/java/HelloWithFunctions.java}

    Dentre as formas descritas anteriormente apenas as seguintes aceitam 
    interpolação: 1, 3 e 4. O resultado da tentativa de utilização da técnica com
    os outros tipos de declarações de string resulta na concatenação da expressão
    não avaliada, ou seja, a própria expressão. Como por exemplo \textbf{\$\{name\}}
    na string final. 

    Os tipos 4 e 5 citados anteriormente produzem um tipo especial de string que
    pode ser expandido por mais de uma linha, por isso são chamados de multilinhas.
    Uma utilização prática e direta da interpolação de strings em conjunto com as
    strings multilinhas é a criação de templates de forma transparente. 
    
    Como dito anteriormente, uma outra forma de declarar uma string é inserindo
    conteúdo entre \emph{/}. Esse tipo de declaração permite criar valores sem 
    ter que escapar caracteres especiais com exceção do próprio \emph{/}. Assim, 
    é possível simplificar por exemplo a escrita de expressões regulares como 
    mostra a listagem \ref{SlashyStringWithRegex}.
    
    \lstinputlisting[
                        style=Groovy,
                        caption=Simplificação de Expressões Regulares com Slashy 
                                Strings,
                        label=SlashyStringWithRegex
                    ]
                    {src/groovy/SlashyStringWithRegex.groovy}

\subsection{Métodos e Closures}

    A linguagem possibilita duas formas de estruturação de blocos de código 
    reutilizáveis. Métodos ou Funções e Closures. A sintaxe de definição de métodos
    é bastante simples e já foi vista nos exemplos anteriores. É necessário apenas
    que se façam alguns esclarecimentos sobre métodos:

    \begin{enumerate}
        \item O tipo de retorno do método bem como a palavra chave \emph{return}
              são opcionais. Por padrão o resultado da avaliação da última linha
              do método é retornada.
        \item Por padrão, propriedades, métodos e classes são públicos. Para alterar
              este comportamento basta utilizar o modificador de acesso correspondente
              para a visibilidade pretendida.
        \item É possível definir parâmetros como valores padrão. Isso possibilita
              que o mesmo método possa ser chamado de diferentes formas. A listagem
              \ref{MethodWithDefaultParameters} exemplifica a sintaxe da declaração.
    \end{enumerate}
    
    \lstinputlisting[
                        style=Groovy,
                        caption=Método com parâmetros com valores padrão,
                        label=MethodWithDefaultParameters
                    ]
                    {src/groovy/MethodWithDefaultParameters.groovy}

\subsection{Closures}

    Closures são pedaços de código reutilizáveis que possuem escopo e podem ser 
    retornados a partir de métodos, atribuídos a propriedades ou variáveis e 
    ainda podem ser utilizados como argumentos em uma chamada de método. 
    
    Estruturas representadas através da notação \{ ... \} representam o closures.
    O código dentro das chaves é executado sempre que a closure é invocada, 
    funcionando de maneira similar aos métodos, podem inclusive ter parâmetros. 
    A diferença básica entre os dois é que as primeiras são objetos enquanto os 
    últimos não. A listagem \ref{HelloClosures} exemplifica a construção de uma 
    closure e sua execução.
    
    \lstinputlisting[
                        style=Groovy,
                        caption=Exemplo de definição e chamada de closures,
                        label=HelloClosures,
                        escapeinside=-+
                    ]
                    {src/groovy/HelloClosures.groovy}
    
\subsection{Collections}

    Groovy possui vários tipos de coleções incluindo listas, mapas, conjuntos,
    arrays e intervalos. Neste artigo, apenas listas e mapas serão explicados.
    
\subsubsection{Listas}

    Assim como em Java, uma lista em Groovy é uma coleção ordernada de objetos.
    Listas em Groovy são uma implementação da interface \emph{java.util.List} sua 
    sintaxe de declaração é semelhante à de arrays como pode ser visto na 
    Listagem \ref{GroovyLists}.
    
    \lstinputlisting[
                        style=Groovy,
                        caption=Listas,
                        label=GroovyLists
                    ]
                    {src/groovy/GroovyLists.groovy}

\subsubsection{Mapas}

    Assim como em Java, um mapa em Groovy é uma coleção não ordenada de pares 
    chave/valor onde as chaves são únicas. A implementação padrão utilizada em 
    Groovy para um mapa é a \emph{java.util.LinkedHashMap} entretanto é possível
    utilizar outras implementações bastando apenas inicializar a variável com o 
    tipo desejado.
    
    De maneira semelhante às listas os mapas podem ser declarados com a notação
    de arrays onde as chaves não são números. A listagem \ref{GroovyMaps} exemplifica
    a utilização de mapas.
    
    \lstinputlisting[  
                        style=Groovy,
                        caption=Mapas,
                        label=GroovyMaps
                    ]
                    {src/groovy/GroovyMaps.groovy}
    
\subsection{Sobrescrita de Operadores}  
    
    Em algumas linguagens é possível redefinir operadores, como por exemplo em 
    C++ e Ruby. Diferente de Java, Groovy que seus operadores sejam redefinidos,
    para tanto, se utiliza de métodos com assinaturas pré-definidas nas classes.
    Assim, é possível, por exemplo, fazer com que dois objetos do tipo BigDecimal
    possam ser adicionados utilizando o operador de adição +. A tabela 
    \ref{tab:OperatorDefinition}, retirada do cartão de referência de \cite{rfcard} 
    exibe os métodos que precisam ser definidos para a utilização dos respectivos 
    operadores.

    \begin{table}[h]
        \centering
        \caption{Sobrescrita de Operadores}
        \label{tab:OperatorDefinition}
        \begin{tabular}{| c | c | c | c |}
        \hline
        {\bf Operador} & {\bf Método} & {\bf Operador} & {\bf Método} \\
        \hline
             a + b &  a.plus(b) & a - b & a.minus(b) \\
        \hline
             a * b & a.multiply(b) & a / b &   a.div(b) \\
        \hline
            a \% b &   a.mod(b) &  a ** b & a.power(b) \\
        \hline
            a \texttt{|} b & a.or(b) & a \texttt{\&} b & a.and(b) \\
        \hline
            a \texttt{\^} b & a.xor(b) & \texttt{\~}a & a.bitwiseNegate() \\
        \hline
            a+ & a.postive() & -a & a.negative() \\
        \hline
            a[b] & a.get(b) & a[b] = c & a.putAt(b, c) \\
        \hline
            a \texttt{<<} b & a.leftShift(b) & a \texttt{>>} b & a.rightShift(b)\\ 
        \hline
            a \texttt{>>>} b & a.rightShiftUnsigned(b) & switch(a) \{case(b) : ... \} & b.isCase(a) \\
        \hline
            a == b & a.equals(b) & a != b & !a.equals(b) \\
        \hline
           a \texttt{<=>} b & a.compareTo(b) & a \texttt{>} b & a.compareTo(b) \texttt{>} 0 \\
        \hline
            a \texttt{>=} b & a.compareTo(b) \texttt{>=} 0 & a \texttt{<} b & a.compareTo(b) \texttt{<} 0 \\
        \hline
            a \texttt{<=} b & a.compareTo(b) \texttt{<= 0} & a as b & a.asType(B) \\
        \hline
            a++ & \multicolumn{ 1}{|c|}{a.next()} & a- - & \multicolumn{ 1}{|c|}{a.previous()} \\
            ++a & \multicolumn{ 1}{|c|}{} & - -a & \multicolumn{ 1}{|c|}{} \\
        \hline
        \end{tabular}  
    \end{table}

\subsection{Operadores Especiais}

    Além dos operadores exibidos na tabela \ref{tab:OperatorDefinition} Groovy 
    oferece outros específicos.

\subsubsection{Operador Elvis}

    De acordo com \cite{beginingGroovy:2008} o operador elvis (?:) é equivalente
    ao operador de if ternário em Java, como demonstra a listagem \ref{ternaryIfJava}.
    Em Groovy o operador Elvis permite a escrita de maneira ainda mais concisa 
    como pode ser visto na listagem \ref{elvisOperatorGroovy} com o código equivalente.
    
    \lstinputlisting[
                        style=Java,
                        caption=Funcionamento do If Ternário em Java,
                        label=ternaryIfJava
                    ]
                    {src/java/TernaryIfJava.java}
    
    \lstinputlisting[
                        style=Groovy,
                        caption=Funcionamento do Operador Elvis,
                        label=elvisOperatorGroovy
                    ]
                    {src/groovy/ElvisOperator.groovy}
                    
\subsubsection{Operador Spread}

    O operador de spread (*.) como explicado na seção de operadores especiais do
    livro Beginning Groovy and Grails From Novice to Professional\cite{beginingGroovy:2008} 
    permite que uma operação seja realizada nos itens de uma coleção de maneira 
    mais sucinta. A listagem a \ref{SpreadOperator} reproduz a listagem listagem
    2-35 do livro citado no início do parágrafo exemplificando duas maneiras de 
    iterar numa lista, através da closure collect() e do operador de spread.
    
    \lstinputlisting[
                        style=Groovy,
                        caption=Listagem 2-35 do livro Beginning Groovy and Grails From Novice to Professional,
                        label=SpreadOperator
                    ]
                    {src/groovy/SpreadOperator.groovy}

% iniciar uma subseção e falar sobre o básico da linguagem
% incluir:
%    shell/console + definição de funções -> DONE
%    Strings: multiline, interpolation -> DONE
%    métodos -> DONE
%    closures -> DONE
%    básico de collections:
%       listas -> DONE
%       mapas -> DONE
%    operators 
%       overloading -> DONE
%       elvis operator -> DONE
%       spread operator -> DONE
%

\subsection{Grails Framework}

%iniciar uma subseção e falar sobre o grails
%incluir:
%   introdução ao grails
%   instalação
%   convention-over-configuration
%   domain classes
%   controllers
%   views
%   scaffolding
%   GORM
%   plugins
%\section{Figures and Captions}\label{sec:figs}
%
%Figure and table captions should be centered if less than one line
%(Figure~\ref{fig:exampleFig1}), otherwise justified and indented by 0.8cm on
%both margins, as shown in Figure~\ref{fig:exampleFig2}. The caption font must
%be Helvetica, 10 point, boldface, with 6 points of space before and after each
%caption.
%
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.5\textwidth]{fig1.jpg}
%\caption{A typical figure}
%\label{fig:exampleFig1}
%\end{figure}
%
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.3\textwidth]{fig2.jpg}
%\caption{This figure is an example of a figure caption taking more than one
%  line and justified considering margins mentioned in Section~\ref{sec:figs}.}
%\label{fig:exampleFig2}
%\end{figure}
%
%In tables, try to avoid the use of colored or shaded backgrounds, and avoid
%thick, doubled, or unnecessary framing lines. When reporting empirical data,
%do not use more decimal digits than warranted by their precision and
%reproducibility. Table caption must be placed before the table (see Table 1)
%and the font used must also be Helvetica, 10 point, boldface, with 6 points of
%space before and after each caption.
%
%\begin{table}[ht]
%\centering
%\caption{Variables to be considered on the evaluation of interaction
%  techniques}
%\label{tab:exTable1}
%\includegraphics[width=.7\textwidth]{table.jpg}
%\end{table}
%
%\section{Images}
%
%All images and illustrations should be in black-and-white, or gray tones,
%excepting for the papers that will be electronically available (on CD-ROMs,
%internet, etc.). The image resolution on paper should be about 600 dpi for
%black-and-white images, and 150-300 dpi for grayscale images.  Do not include
%images with excessive resolution, as they may take hours to print, without any
%visible difference in the result. 
%
%
%Bibliographic references must be unambiguous and uniform.  We recommend giving
%the author names references in brackets, e.g. \cite{knuth:84},
%\cite{boulic:91}, and \cite{smith:99} and \cite{beginingGroovy:2008}, \cite{groovy}, \cite{rfcard}.
%
%The references must be listed using 12 point font size, with 6 points of space
%before each reference. The first line of each reference should not be
%indented, while the subsequent should be indented by 0.5 cm.

\bibliographystyle{sbc}
\bibliography{artigo}

\end{document}
